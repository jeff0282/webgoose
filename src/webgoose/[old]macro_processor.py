
import re
from typing import Optional, Tuple

from bs4 import BeautifulSoup

from src.webgoose import macros
from src.webgoose.config import config


class MacroProcessor():
    

    IGNORE_MACRO_PREFIX = "//"

    GLOBAL_MACROS = {

        "last_modified":    macros.last_modified, 
        "version":          macros.get_version,
        "toc":              macros.table_of_contents,
        "index":            macros.index,
        "time":             macros.get_time,
        "docroot":          macros.docroot

    }



    def __init__(self, page_dict: dict, content: str, reference: Optional[str] = False):

        """
        Takes:
        - page_dict     ->  Dictionary generated by Page Class which holds all page information

        - content       ->  the content containing the macros to be processed

        - reference     ->  an optional argument if the macro processor should use another piece of 
                            content to reference values from (useful for processing macros on templates, 
                            allows use of page content instead of template to reference values 
                            (e.g. table of contents)).

        """
        
        self.page_dict = page_dict

        self.content = content

        self.reference = reference if reference else self.content





    def process(self) -> str:

        """
        Applies Macros To Page (through __apply_macros)
        """
        
        # Process All Macros On Page
        processed_content = self.__apply_macros(self.content)

        # Clean Up (remove comment prefixes from commented out macros)
        processed_content = processed_content.replace(self.IGNORE_MACRO_PREFIX+"{@", "{@")

        return processed_content





    def __apply_macros(self, content: str) -> str:

        """
        Finds and Replaces Macros With Their Respective Output By Way Of Regex
        """

        # Compile Regex Pattern (Purely For Sake Of Keeping Code Tidy)
        pattern = re.compile(r"(?<!"+self.IGNORE_MACRO_PREFIX+r"){@([^@\n\r]+)@}")

        return re.sub(pattern, self.__apply_single_macro, content)






    def __apply_single_macro(self, macro: str) -> str:

        """
        Checks Validity Of and Gets The Output Of A Single Macro

        If Any Issue Occurs, It Just Spits Out The Empty String As The Macro Output
        """

        # Default Result For Macro Is To Replace Macro With Nothing
        # Only Return Proper Content If Macro Is Valid
        macro_result = ""

        # Get Macro Name And Arguments As Key Value Dictionary From Macro String
        command, arg_dict = self.__parse_macro(macro.group())

        # Apply Macro If Present In The Global Macro Dict or Specified In Config as Local Macro
        if command in self.GLOBAL_MACROS:

            macro_result = self.GLOBAL_MACROS[command](self.page_dict, self.reference, arg_dict)

        elif command in config['macros']:

            macro_result = config['macros'][command]


        # Macros Can Be Nested, So Necessary To Apply To Output
        # !!! This Can Result In Recursion Depth Errors In Cases Of Infinite Nesting
        return self.__apply_macros(macro_result)




    
    def __parse_macro(self, macro: str) -> Tuple[str, dict[str]]:

        """
        Parses Any Given Macro And Returns Its Name and Arguments

        Formats Macros So That:

            - {@ last_modified page=index.html format="%Y" @}

        Becomes:

            - Command: time
            - Argument: {'page': 'index.html', 'format': '%Y'}
        """

        # Use BeautifulSoup Parser To Convert HTML Entities To Normal Text
        # (convert to string as it's a BeautifulSoup object by default)
        macro = str(BeautifulSoup(macro, "html.parser"))

        # Remove Macro Delimeters {@ ... @}, Strip Any Outer Whitespace
        macro = macro[2:-2].strip()

        # Extract Macro Name
        command = re.match(r"^([^\s]+)", macro).group()
        
        # Extract Argument Keywords & Values From Macro
        arg_keywords = re.findall(r"(?<=\s)([^\s]+)(?=\=)", macro)

        arg_values = re.findall(r"(?<=\=\")([^\"]*)(?=\")", macro)

        # Create Dictionary From Keyword and Value Lists, If Arguments Were Provided
        # [NOTE] If List Lengths Are Mismatched, The Entire Entry (keyword: value) Will Be Ignored
        if arg_keywords and arg_values:
            
            arg_dict = {key:value for (key, value) in zip(arg_keywords, arg_values)}
            
            return command, arg_dict 

        return command, {}


        

